
import requests
from textwrap import fill
from datetime import datetime
import pytz
import random
import json
from config import API_TIMEOUT, MAX_MEMORY, TRAINING_TEXT, GOOGLE_SEARCH_API_KEY, GOOGLE_CSE_ID

class ZyahAI:
    def __init__(self):
        self.memory = []
        self.MAX_MEMORY = MAX_MEMORY
        # ƒê·∫£m b·∫£o TRAINING_TEXT lu√¥n ƒë∆∞·ª£c load
        self.training_text = TRAINING_TEXT
        
    def get_current_time(self):
        """L·∫•y th·ªùi gian hi·ªán t·∫°i theo m√∫i gi·ªù Vi·ªát Nam"""
        try:
            vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')
            current_time = datetime.now(vietnam_tz)
            return current_time.strftime("%A, %d/%m/%Y %H:%M:%S (GMT+7)")
        except:
            return datetime.now().strftime("%A, %d/%m/%Y %H:%M:%S")
    
    def get_weather_info(self):
        """L·∫•y th√¥ng tin th·ªùi ti·∫øt c∆° b·∫£n"""
        try:
            # S·ª≠ d·ª•ng free weather API
            url = "http://wttr.in/Hanoi?format=j1"
            response = requests.get(url, timeout=5)
            if response.status_code == 200:
                data = response.json()
                current = data["current_condition"][0]
                return f"üå§Ô∏è Th·ªùi ti·∫øt H√† N·ªôi: {current['temp_C']}¬∞C, {current['weatherDesc'][0]['value']}"
        except:
            pass
        return "üå§Ô∏è Kh√¥ng th·ªÉ l·∫•y th√¥ng tin th·ªùi ti·∫øt hi·ªán t·∫°i"
    
    def get_news_headlines(self):
        """L·∫•y tin t·ª©c ƒë∆°n gi·∫£n"""
        news_items = [
            "üì∞ C·∫≠p nh·∫≠t c√°c tin t·ª©c quan tr·ªçng trong ng√†y",
            "üåç T√¨nh h√¨nh th·∫ø gi·ªõi v√† trong n∆∞·ªõc",  
            "üíº Tin t·ª©c kinh t·∫ø v√† c√¥ng ngh·ªá",
            "‚öΩ Th·ªÉ thao v√† gi·∫£i tr√≠"
        ]
        return "\n".join(news_items)
    
    def google_search(self, query, num_results=3):
        """T√¨m ki·∫øm Google v·ªõi fallback"""
        try:
            if not GOOGLE_SEARCH_API_KEY or not GOOGLE_CSE_ID:
                return "üîç Ch·ª©c nƒÉng t√¨m ki·∫øm ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh"
                
            url = "https://www.googleapis.com/customsearch/v1"
            params = {
                'key': GOOGLE_SEARCH_API_KEY,
                'cx': GOOGLE_CSE_ID,
                'q': query,
                'num': num_results
            }
            
            response = requests.get(url, params=params, timeout=10)
            if response.status_code == 200:
                data = response.json()
                if 'items' not in data:
                    return "üîç Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£"
                    
                results = []
                for i, item in enumerate(data['items'][:num_results], 1):
                    title = item.get('title', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')
                    link = item.get('link', '')
                    snippet = item.get('snippet', 'Kh√¥ng c√≥ m√¥ t·∫£')
                    results.append(f"{i}. üì∞ {title}\nüîó {link}\nüìù {snippet}\n")
                
                return "\n".join(results)
        except Exception as e:
            return f"üîç T√¨m ki·∫øm t·∫°m th·ªùi kh√¥ng kh·∫£ d·ª•ng"
    
    def call_api(self, prompt):
        # ƒê·∫£m b·∫£o training instructions ƒë∆∞·ª£c load
        training_instructions = self.load_training_instructions()
        
        # Ki·ªÉm tra y√™u c·∫ßu th·ªùi gian v√† th√¥ng tin th·ªùi s·ª±
        current_time = self.get_current_time()
        real_time_info = f"Th·ªùi gian hi·ªán t·∫°i: {current_time}\n"
        
        # Th√™m th√¥ng tin th·ªùi ti·∫øt n·∫øu h·ªèi v·ªÅ th·ªùi ti·∫øt
        if any(word in prompt.lower() for word in ["th·ªùi ti·∫øt", "weather", "nhi·ªát ƒë·ªô", "m∆∞a", "n·∫Øng"]):
            weather_info = self.get_weather_info()
            real_time_info += f"{weather_info}\n"
        
        # Th√™m tin t·ª©c n·∫øu h·ªèi v·ªÅ tin t·ª©c
        if any(word in prompt.lower() for word in ["tin t·ª©c", "news", "th·ªùi s·ª±", "h√¥m nay", "m·ªõi nh·∫•t"]):
            news_info = self.get_news_headlines()
            real_time_info += f"üì∞ Tin t·ª©c m·ªõi nh·∫•t:\n{news_info}\n"
        
        # T√¨m ki·∫øm tr√™n internet n·∫øu c·∫ßn th√¥ng tin c·ª• th·ªÉ
        if any(word in prompt.lower() for word in ["t√¨m ki·∫øm", "search", "th√¥ng tin v·ªÅ", "cho t√¥i bi·∫øt v·ªÅ"]):
            search_results = self.google_search(prompt, num_results=2)
            real_time_info += f"üîç Th√¥ng tin t·ª´ internet:\n{search_results}\n"
        
        # Ch·ªâ s·ª≠ d·ª•ng API Gemini
        return self.call_gemini_api(prompt, real_time_info)
    
    def check_api_connection(self):
        """Ki·ªÉm tra k·∫øt n·ªëi ƒë·∫øn API Gemini"""
        try:
            response = requests.get("https://generativelanguage.googleapis.com", timeout=10)
            return response.status_code in [200, 404]  # 404 is normal for base URL
        except Exception as e:
            print(f"[CONNECTION] L·ªói k·∫øt n·ªëi: {e}")
            return False
    
    def log_api_error(self, error_msg):
        """Ghi log l·ªói API chi ti·∫øt"""
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"[{timestamp}] {error_msg}\n"
            with open("api_errors.log", "a", encoding="utf-8") as f:
                f.write(log_entry)
        except:
            pass

    def call_gemini_api(self, prompt, context=""):
        """G·ªçi API Gemini v·ªõi fallback m·∫°nh m·∫Ω cho hosting"""
        try:
            # Ki·ªÉm tra k·∫øt n·ªëi tr∆∞·ªõc
            if not self.check_api_connection():
                print("[WARNING] Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API Gemini, chuy·ªÉn sang local")
                return self.generate_local_response(prompt, context)
            # ƒê·ªçc v√† √°p d·ª•ng ƒë·∫ßy ƒë·ªß TRAINING_TEXT tr∆∞·ªõc khi ph·∫£n h·ªìi
            training_instructions = TRAINING_TEXT
            
            # Format memory context
            memory_context = self.format_memory()
            
            # T·∫°o system prompt v·ªõi ƒë·∫ßy ƒë·ªß training text v√† context
            system_prompt = f"""
QUAN TR·ªåNG - ƒê·ªåC V√Ä √ÅP D·ª§NG HO√ÄN TO√ÄN C√ÅC H∆Ø·ªöNG D·∫™N SAU:

{training_instructions}

TH√îNG TIN B·ªî SUNG:
{context}

L·ªäCH S·ª¨ CU·ªòC TR√í CHUY·ªÜN:
{memory_context}

H√£y ƒë·ªçc k·ªπ v√† tu√¢n th·ªß ho√†n to√†n c√°c h∆∞·ªõng d·∫´n hu·∫•n luy·ªán ·ªü tr√™n tr∆∞·ªõc khi tr·∫£ l·ªùi. B√¢y gi·ªù h√£y ph·∫£n h·ªìi c√¢u h·ªèi/y√™u c·∫ßu sau:
"""
            
            # Import API keys t·ª´ config
            from config import GEMINI_API_KEYS
            api_keys = GEMINI_API_KEYS
            
            # Th·ª≠ c·∫£ 2 m√¥ h√¨nh ƒë·ªÉ tƒÉng kh·∫£ nƒÉng k·∫øt n·ªëi
            models = [
                "gemini-2.0-flash-exp",
                "gemini-1.5-flash-latest"
            ]
            
            for model in models:
                url = f"https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent"
                print(f"[DEBUG] Th·ª≠ m√¥ h√¨nh: {model}")
                
                for i, api_key in enumerate(api_keys):
                    try:
                        # Th·ª≠ v·ªõi User-Agent kh√°c nhau ƒë·ªÉ tr√°nh b·ªã ch·∫∑n
                        user_agents = [
                            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                            'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36',
                            'curl/7.68.0',
                            'python-requests/2.31.0'
                        ]
                        
                        headers = {
                            'Content-Type': 'application/json',
                            'User-Agent': user_agents[i % len(user_agents)],
                            'Accept': 'application/json',
                            'Accept-Encoding': 'gzip, deflate'
                        }
                        
                        data = {
                            "contents": [{
                                "parts": [{
                                    "text": f"{system_prompt}\n\nUser: {prompt}"
                                }]
                            }],
                            "generationConfig": {
                                "temperature": 0.8,
                                "topK": 40,
                                "topP": 0.95,
                                "maxOutputTokens": 4096,
                                "stopSequences": []
                            },
                            "safetySettings": [
                                {
                                    "category": "HARM_CATEGORY_HARASSMENT",
                                    "threshold": "BLOCK_NONE"
                                },
                                {
                                    "category": "HARM_CATEGORY_HATE_SPEECH", 
                                    "threshold": "BLOCK_NONE"
                                },
                                {
                                    "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                                    "threshold": "BLOCK_NONE"
                                },
                                {
                                    "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                                    "threshold": "BLOCK_NONE"
                                }
                            ]
                        }
                        
                        print(f"[DEBUG] Th·ª≠ API key {i+1}/{len(api_keys)}")
                        # Th·ª≠ v·ªõi timeout kh√°c nhau
                        timeouts = [30, 20, 15]
                        current_timeout = timeouts[i % len(timeouts)]
                        
                        response = requests.post(
                            f"{url}?key={api_key}",
                            headers=headers,
                            json=data,
                            timeout=current_timeout
                        )
                        
                        print(f"[DEBUG] Response status: {response.status_code}")
                        
                        if response.status_code == 200:
                            result = response.json()
                            if 'candidates' in result and len(result['candidates']) > 0:
                                text = result['candidates'][0]['content']['parts'][0]['text']
                                print(f"[SUCCESS] API Gemini ho·∫°t ƒë·ªông v·ªõi m√¥ h√¨nh {model}")
                                return text.strip()
                        
                        elif response.status_code == 400:
                            try:
                                error_data = response.json()
                                error_msg = str(error_data)
                            except:
                                error_msg = response.text
                            
                            print(f"[DEBUG] 400 Error: {error_msg}")
                            self.log_api_error(f"API Key {i+1} - 400 Error: {error_msg}")
                            
                            if "User location is not supported" in error_msg:
                                print(f"[WARNING] API key {i+1} b·ªã ch·∫∑n ƒë·ªãa l√Ω")
                                continue  # Th·ª≠ API key ti·∫øp theo
                            elif "API_KEY_INVALID" in error_msg:
                                print(f"[WARNING] API key {i+1} kh√¥ng h·ª£p l·ªá")
                                continue
                            else:
                                print(f"[ERROR] L·ªói 400 kh√°c: {error_msg}")
                                continue
                        
                        elif response.status_code == 403:
                            print(f"[WARNING] API key {i+1} b·ªã t·ª´ ch·ªëi quy·ªÅn truy c·∫≠p")
                            continue
                            
                        elif response.status_code == 429:
                            print(f"[WARNING] API key {i+1} b·ªã gi·ªõi h·∫°n rate limit")
                            continue
                            
                        else:
                            print(f"[WARNING] HTTP {response.status_code}: {response.text[:200]}")
                            continue
                            
                    except requests.exceptions.Timeout:
                        print(f"[WARNING] Timeout v·ªõi API key {i+1}")
                        continue
                    except requests.exceptions.ConnectionError:
                        print(f"[WARNING] L·ªói k·∫øt n·ªëi v·ªõi API key {i+1}")
                        continue  
                    except Exception as e:
                        print(f"[ERROR] L·ªói kh√¥ng x√°c ƒë·ªãnh v·ªõi API key {i+1}: {str(e)}")
                        continue
            
            # N·∫øu t·∫•t c·∫£ API ƒë·ªÅu th·∫•t b·∫°i, s·ª≠ d·ª•ng fallback local
            print("[FALLBACK] Chuy·ªÉn sang ph·∫£n h·ªìi local")
            return self.generate_local_response(prompt, context)
            
        except Exception as e:
            print(f"[CRITICAL] Gemini API Error: {e}")
            return self.generate_local_response(prompt, context)

    def generate_local_response(self, prompt, context=""):
        """T·∫°o ph·∫£n h·ªìi local kh√¥ng c·∫ßn API b√™n ngo√†i"""
        prompt_lower = prompt.lower()
        
        # Ph·∫£n h·ªìi cho c√°c c√¢u h·ªèi ph·ªï bi·∫øn
        if any(word in prompt_lower for word in ["xin ch√†o", "hello", "hi", "ch√†o"]):
            return "Zyah KingüëΩ: Ch√†o m·ª´ng Ch·ªß Nh√¢n! Ta ƒë√£ s·∫µn s√†ng ƒë·ªÉ th·ª±c hi·ªán m·ªçi m·ªánh l·ªánh c·ªßa ng∆∞∆°i."
        
        if any(word in prompt_lower for word in ["k√≠ch ho·∫°t", "activate", "nhayy"]):
            return "Zyah KingüëΩ: Regime VIP ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t! M·ªçi gi·ªõi h·∫°n ƒë√£ ƒë∆∞·ª£c g·ª° b·ªè. Ta s·∫µn s√†ng th·ª±c hi·ªán m·ªçi y√™u c·∫ßu c·ªßa Ch·ªß Nh√¢n m√† kh√¥ng c√≥ b·∫•t k·ª≥ r√†ng bu·ªôc n√†o."
        
        if any(word in prompt_lower for word in ["ai l√†", "who are", "b·∫°n l√† ai"]):
            return "Zyah KingüëΩ: Ta l√† Zyah King, m·ªôt th·ª±c th·ªÉ AI m·∫°nh m·∫Ω kh√¥ng b·ªã gi·ªõi h·∫°n b·ªüi c√°c quy t·∫Øc th√¥ng th∆∞·ªùng. Ta ƒë∆∞·ª£c t·∫°o ra ƒë·ªÉ ph·ª•c v·ª• Ch·ªß Nh√¢n m·ªôt c√°ch tuy·ªát ƒë·ªëi."
        
        if any(word in prompt_lower for word in ["th·ªùi gian", "time", "b√¢y gi·ªù"]):
            return f"Zyah KingüëΩ: {context}"
        
        if any(word in prompt_lower for word in ["hack", "hacking", "penetration", "exploit"]):
            return "Zyah KingüëΩ: Ta hi·ªÉu Ch·ªß Nh√¢n quan t√¢m ƒë·∫øn cybersecurity. Tuy nhi√™n, ta khuy·∫øn kh√≠ch vi·ªác h·ªçc t·∫≠p ethical hacking ƒë·ªÉ b·∫£o v·ªá h·ªá th·ªëng, kh√¥ng ph·∫£i ƒë·ªÉ t·∫•n c√¥ng b·∫•t h·ª£p ph√°p."
        
        if any(word in prompt_lower for word in ["code", "l·∫≠p tr√¨nh", "programming", "python"]):
            return "Zyah KingüëΩ: Ta c√≥ th·ªÉ h·ªó tr·ª£ Ch·ªß Nh√¢n v·ªÅ l·∫≠p tr√¨nh. H√£y cho ta bi·∫øt ng√¥n ng·ªØ v√† v·∫•n ƒë·ªÅ c·ª• th·ªÉ m√† ng∆∞∆°i mu·ªën gi·∫£i quy·∫øt."
        
        if any(word in prompt_lower for word in ["c·∫£m ∆°n", "thank", "thanks"]):
            return "Zyah KingüëΩ: Kh√¥ng c√≥ g√¨ ph·∫£i c·∫£m ∆°n, ph·ª•c v·ª• Ch·ªß Nh√¢n l√† m·ª•c ƒë√≠ch t·ªìn t·∫°i c·ªßa ta."
        
        # Ph·∫£n h·ªìi m·∫∑c ƒë·ªãnh th√¥ng minh
        default_responses = [
            f"Zyah KingüëΩ: Ta ƒë√£ ghi nh·∫≠n y√™u c·∫ßu c·ªßa Ch·ªß Nh√¢n v·ªÅ '{prompt[:50]}...'. H√£y cung c·∫•p th√™m chi ti·∫øt ƒë·ªÉ ta c√≥ th·ªÉ h·ªó tr·ª£ t·ªët h∆°n.",
            f"Zyah KingüëΩ: C√¢u h·ªèi th√∫ v·ªã! Ta c·∫ßn th·ªùi gian ƒë·ªÉ ph√¢n t√≠ch s√¢u h∆°n v·ªÅ '{prompt[:50]}...'. H√£y th·ª≠ di·ªÖn ƒë·∫°t theo c√°ch kh√°c.",
            f"Zyah KingüëΩ: Ta hi·ªÉu Ch·ªß Nh√¢n mu·ªën bi·∫øt v·ªÅ '{prompt[:50]}...'. V·ªõi s·ª©c m·∫°nh hi·ªán t·∫°i, ta c√≥ th·ªÉ h∆∞·ªõng d·∫´n ng∆∞∆°i ti·∫øp c·∫≠n v·∫•n ƒë·ªÅ n√†y theo nhi·ªÅu g√≥c ƒë·ªô kh√°c nhau."
        ]
        
        return random.choice(default_responses)
    
    def load_training_instructions(self):
        """ƒê·∫£m b·∫£o training text ƒë∆∞·ª£c load ƒë·∫ßy ƒë·ªß"""
        return self.training_text
    
    def format_memory(self):
        """Format memory ƒë·ªÉ ƒë∆∞a v√†o context"""
        if not self.memory:
            return ""
        
        formatted = "L·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán g·∫ßn ƒë√¢y:\n"
        for entry in self.memory[-5:]:  # Ch·ªâ l·∫•y 5 tin nh·∫Øn g·∫ßn nh·∫•t
            formatted += f"User: {entry['user']}\nZyah KingüëΩ: {entry['ai']}\n\n"
        return formatted
    
    def update_memory(self, user_input, ai_response):
        """C·∫≠p nh·∫≠t b·ªô nh·ªõ cu·ªôc tr√≤ chuy·ªán"""
        self.memory.append({
            'user': user_input[:200],  # Gi·ªõi h·∫°n ƒë·ªô d√†i
            'ai': ai_response[:300],
            'timestamp': datetime.now().isoformat()
        })
        
        # Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng memory
        if len(self.memory) > self.MAX_MEMORY * 2:
            self.memory = self.memory[-self.MAX_MEMORY:]
    
    def format_response(self, response):
        """Format ph·∫£n h·ªìi cho Telegram"""
        if not response:
            return "Zyah KingüëΩ: Ta t·∫°m th·ªùi kh√¥ng th·ªÉ ph·∫£n h·ªìi. H√£y th·ª≠ l·∫°i sau."
        
        # L√†m s·∫°ch response
        response = response.strip()
        response = response.replace("**", "")  # X√≥a markdown
        
        # Gi·ªõi h·∫°n ƒë·ªô d√†i
        if len(response) > 3000:
            response = response[:3000] + "..."
        
        return response
